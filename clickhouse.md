# 性能测试

​    所有用于对比的数据库都使用了相同配置的服务器，在单个节点的情况下，对一张拥有133个字段的数据表分别在1000万、1亿和10亿三种数据体量下执行基准测试，基准测试的范围涵盖43项SQL查询。在1亿数据集体量的情况下，ClickHouse的平均响应速度是Vertica的2.63倍、InfiniDB的17倍、MonetDB的27倍、Hive的126倍、MySQL的429倍以及Greenplum的10倍。详细的测试结果可以查阅https://clickhouse.yandex/benchmark.html。



# ClickHouse 发展历程

#### 1 mysql 时期

> 因为Yandex内部的这套MySQL方案使用了MyISAM表引擎，所以Yandex.Metrica也延续了表引擎的选择。这类分析场景更关注数据写入和查询的性能，不关心事务操作（MyISAM表引擎不支持事务特性）。相比InnoDB表引擎，MyISAM表引擎在分析场景中具有更好的性能。
>
> 
>
> 随着时间的推移，MySQL中的数据越来越多（截至2011年，存储的数据超过5800亿行）。虽然Yandex又额外做了许多优化，成功地将90%的分析报告控制在26秒内返回，但是这套技术方案越来越显得力不从心。



#### 2 Metrage 时期

> 由于MySQL带来的局限性，Yandex自研了一套全新的系统并命名为Metrage。Metrage在设计上与MySQL完全不同，它选择了另外一条截然不同的道路。首先，在数据模型层面，它使用Key-Value模型（键值对）代替了关系模型；其次，在索引层面，它使用LSM树代替了B+树；最后，在数据处理层面，由实时查询的方式改为了预处理的方式。
>
> 
>
> 截至2015年，在Metrage内存储了超过3万亿行的数据，其集群规模超过了60台服务器，查询性能也由先前的26秒降低到了惊人的1秒以内。然而，使用立方体这类预先聚合的思路会带来一个新的问题，那就是维度组合爆炸，因为需要预先对所有的维度组合进行计算。那么维度组合的方式具体有多少种呢？它的计算公式是2N（N =维度数量）。可以做一次简单的计算，例如5个维度的组合方式会有25=32种，而9个维度的组合方式则会多达29=512种，这是一种指数级的增长方式。维度组合的爆炸会直接导致数据膨胀，有时候这种膨胀可能会多达10～20倍。



#### 3 OLAPServer 时期

#### 4 ClickHouse 时期

> ClickHouse的全称是Click Stream,Data WareHouse，简称ClickHouse
>
> 
>
> ClickHouse已经为Yandex.Metrica存储了超过20万亿行的数据，90%的自定义查询能够在1秒内返回，其集群规模也超过了400台服务器。



#### 5 ClickHouse 不适用的场景

> 不支持事务。
>
> 不擅长根据主键按行粒度进行查询（虽然支持），故不应该把ClickHouse当作Key-Value数据库使用。
>
> 不擅长按行删除数据（虽然支持）。



# ClickHouse 核心特征

#### 1 列式存储和数据压缩

> ClickHouse就是一款使用列式存储的数据库，数据按列进行组织，属于同一列的数据会被保存在一起，列与列之间也会由不同的文件分别保存（这里主要指MergeTree表引擎，表引擎会在后续章节详细介绍）。数据默认使用LZ4算法压缩，在Yandex.Metrica的生产环境中，数据总体的压缩比可以达到8:1（未压缩前17PB，压缩后2PB）。列式存储除了降低IO和存储的压力之外，还为向量化执行做好了铺垫。



#### 2 向量化执行引擎

> 为了实现向量化执行，需要利用CPU的SIMD指令。SIMD的全称是Single Instruction MultipleData，即用单条指令操作多条数据。现代计算机系统概念中，它是通过数据并行以提高性能的一种实现方式（其他的还有指令级并行和线程级并行），它的原理是在CPU寄存器层面实现数据的并行操作。
>
> 
>
> ClickHouse目前利用SSE4.2指令集实现向量化执行。



#### 3 表引擎

> 与MySQL类似，ClickHouse也将存储部分进行了抽象，把存储引擎作为一层独立的接口。截至本书完稿时，ClickHouse共拥有合并树、内存、文件、接口和其他6大类20多种表引擎。



#### 4 多主架构

> ClickHouse支持分片，而分片则依赖集群。每个集群由1到多个分片组成，而每个分片则对应了ClickHouse的1个服务节点。分片的数量上限取决于节点数量（1个分片只能对应1个服务节点）。
>
> 
>
> ClickHouse并不像其他分布式系统那样，拥有高度自动化的分片功能。ClickHouse提供了本地表（Local Table）与分布式表（Distributed Table）的概念。一张本地表等同于一份数据的分片。而分布式表本身不存储任何数据，它是本地表的访问代理，其作用类似分库中间件。借助分布式表，能够代理访问多个数据分片，从而实现分布式查询。



# Clickhouse 架构

#### 1 block和block流

> Block对象的本质是由数据对象、数据类型和列名称组成的三元组，即Column、DataType及列名称字符串。Column提供了数据的读取能力，而DataType知道如何正反序列化，所以Block在这些对象的基础之上实现了进一步的抽象和封装，从而简化了整个使用的过程，仅通过Block对象就能完成一系列的数据操作。



# ClickHouse 为什么快

#### 1 硬件

> 基于将硬件功效最大化的目的，ClickHouse会在内存中进行GROUP BY，并且使用HashTable装载数据。与此同时，他们非常在意CPU L3级别的缓存，因为一次L3的缓存失效会带来70～100ns的延迟。
>
> ClickHouse在基准查询中能做到1.75亿次/秒的数据扫描性能。



#### 2 算法

> 以字符串为例，有一本专门讲解字符串搜索的书，名为“Handbook of Exact String Matching Algorithms”，列举了35种常见的字符串搜索算法。各位猜一猜ClickHouse使用了其中的哪一种？答案是一种都没有。这是为什么呢？因为性能不够快。在字符串搜索方面，针对不同的场景，ClickHouse最终选择了这些算法：对于常量，使用Volnitsky算法；对于非常量，使用CPU的向量化执行SIMD，暴力优化；正则匹配使用re2和hyperscan算法。性能是算法选择的首要考量指标。
>
> 例如去重计数uniqCombined函数，会根据数据量的不同选择不同的算法：当数据量较小的时候，会选择Array保存；当数据量中等的时候，会选择HashSet；而当数据量很大的时候，则使用HyperLogLog算法。
>
> SIMD被广泛地应用于文本转换、数据过滤、数据解压和JSON转换等场景。相较于单纯地使用CPU，利用寄存器暴力优化也算是一种降维打击了。



# ClickHouse 操作

> ![image-20210426174121840](clickhouse.assets/image-20210426174121840.png)



#### 1 访问接口

CLI基于TCP，JDBC基于HTTP。JDBC分标准模式和高可用模式。高可用模式允许设置多个host地址，每次会从可用的地址中随机选择一个进行连接。在高可用模式下，需要通过BalancedClickhouseDataSource对象获取连接。

#### 2 基准测试

> clickhouse-benchmark是基准测试的小工具，它可以自动运行SQL查询，并生成相应的运行指标报。
>
> ![image-20210426175225278](clickhouse.assets/image-20210426175225278.png)



# 数据定义

#### 1 数据类型

基础类型、复合类型和特殊类型



#### 2 基础类型

>  ClickHouse的浮点数支持正无穷、负无穷以及非数字的表达方式。



##### 2.1 Decimal类型

> 对于不同精度定点数之间的四则运算，其精度S的变化会遵循下表的规则。
>
> ![image-20210426175919619](clickhouse.assets/image-20210426175919619.png)
>
> 
>
> 在使用定点数时还有一点值得注意：由于现代计算器系统只支持32位和64位CPU，所以Decimal128是在软件层面模拟实现的，它的速度会明显慢于Decimal32与Decimal64。



##### 2.2 字符串类型

* String，无长度限制，无字符集概念，不限制字符集。

* FixedString，与Char类型，有确定长度。但是FixedString用null填充末尾，Char用空格填充。

* UUID

>  UUID是一种数据库常见的主键类型，在ClickHouse中直接把它作为一种数据类型。UUID共有32位，它的格式为8-4-4-4-12。如果一个UUID类型的字段在写入数据时没有被赋值，则会依照格式使用0填充



##### 2.3 时间类型

> 时间类型分为DateTime、DateTime64和Date三类。ClickHouse目前没有时间戳类型。时间类型最高的精度是秒，也就是说，如果需要处理毫秒、微秒等大于秒分辨率的时间，则只能借助UInt类型实现。



#### 3 复合类型

##### 3.1 Array 数组

##### 3.2 Tuple 元组

##### 3.3 枚举

> 枚举固定使用(String:Int)Key/Value键值对的形式定义数据，所以Enum8和Enum16分别会对应(String:Int8)和(String:Int16)。
>
> 在定义枚举集合的时候，有几点需要注意。首先，Key和Value是不允许重复的，要保证唯一性。其次，Key和Value的值都不能为Null，但Key允许是空字符串。在写入枚举数据的时候，只会用到Key字符串部分。
>
> 可能有人会觉得，完全可以使用String代替枚举，为什么还需要专门的枚举类型呢？这是出于性能的考虑。因为虽然枚举定义中的Key属于String类型，但是在后续对枚举的所有操作中（包括排序、分组、去重、过滤等），会使用Int类型的Value值。

##### 3.5 Nested 嵌套类型

嵌套层级只支持一级

> ![image-20210426181604939](clickhouse.assets/image-20210426181604939.png)



#### 4 特殊类型

Nullable 和 Domain